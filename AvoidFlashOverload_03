#include <stdio.h>
#include <stdlib.h>
#include <esp_mac.h>
#include "rand_num.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/semphr.h"
#include "driver/gpio.h"
#include "esp_err.h"
#include "nvs_flash.h"

#define LED1_PIN GPIO_NUM_32
#define LED2_PIN GPIO_NUM_33
#define BTN1_PIN GPIO_NUM_14
#define QUEUE_SIZE 16
#define MIN_1 -5
#define MIN_2 -7
#define MAX_1 5
#define MAX_2 7

BaseType_t th_gen_num_1, th_gen_num_2, th_read_num_1, th_read_num_2;
TaskHandle_t th_handle_1, th_handle_2, th_handle_3, th_handle_4;
QueueHandle_t queue_handle_1, queue_handle_2;
SemaphoreHandle_t mutex;

void taskReadNVS(void);
void taskGenNum1(void);
void taskGenNum2(void);
void taskReadNum1(void *pvParameter);
void taskReadNum2(void *pvParameter);

void taskGenNum1(void)
{
  int16_t ran_num_1;
  while (1)
  {
    ran_num_1 = genRanNum(-10, 10);
    xQueueSend(queue_handle_1, &ran_num_1, portMAX_DELAY);
    vTaskDelay(pdMS_TO_TICKS(1000));
  }
}

void taskGenNum2(void)
{
  int16_t ran_num_2;
  while (1)
  {
    ran_num_2 = genRanNum(-10, 10);
    xQueueSend(queue_handle_2, &ran_num_2, portMAX_DELAY);
    vTaskDelay(pdMS_TO_TICKS(1000));
  }
}

void taskReadNum1(void *pvParameter)
{
  int16_t received_num_1;
  esp_err_t err;
  nvs_handle_t nvs_handle_1;

  err = nvs_open("storage", NVS_READWRITE, &nvs_handle_1);
  if (err != ESP_OK)
  {
    printf("Error opening NVS: %s\n", esp_err_to_name(err));
    vTaskDelete(NULL);
  }

  while (1)
  {
    xQueueReceive(queue_handle_1, &received_num_1, portMAX_DELAY);

    if (xSemaphoreTake(mutex, portMAX_DELAY) == pdTRUE)
    {
      if (received_num_1 < MIN_1 || received_num_1 > MAX_1)
      {
        gpio_set_level(LED1_PIN, 0);
        vTaskDelay(pdMS_TO_TICKS(1000));

        err = nvs_set_i32(nvs_handle_1, "th_read_num_1", received_num_1);
        if (err != ESP_OK)
        {
          printf("Error writing to NVS: %s\n", esp_err_to_name(err));
        }

        err = nvs_commit(nvs_handle_1);
        if (err != ESP_OK)
        {
          printf("Error committing to NVS: %s\n", esp_err_to_name(err));
        }

        gpio_set_level(LED1_PIN, 1);
      }
      xSemaphoreGive(mutex);
    }
    else
    {
      printf("Error taking mutex\n");
    }
  }

  nvs_close(nvs_handle_1);
}

void taskReadNum2(void *pvParameter)
{
  int16_t received_num_2;
  esp_err_t err;
  nvs_handle_t nvs_handle_2;

  err = nvs_open("storage", NVS_READWRITE, &nvs_handle_2);
  if (err != ESP_OK)
  {
    printf("Error opening NVS: %s\n", esp_err_to_name(err));
    vTaskDelete(NULL);
  }

  while (1)
  {
    xQueueReceive(queue_handle_2, &received_num_2, portMAX_DELAY);

    if (xSemaphoreTake(mutex, portMAX_DELAY) == pdTRUE)
    {
      if (received_num_2 < MIN_2 || received_num_2 > MAX_2)
      {
        gpio_set_level(LED2_PIN, 0);
        vTaskDelay(pdMS_TO_TICKS(1000));

        err = nvs_set_i32(nvs_handle_2, "th_read_num_2", received_num_2);
        if (err != ESP_OK)
        {
          printf("Error writing to NVS: %s\n", esp_err_to_name(err));
        }

        err = nvs_commit(nvs_handle_2);
        if (err != ESP_OK)
        {
          printf("Error committing to NVS: %s\n", esp_err_to_name(err));
        }

        gpio_set_level(LED2_PIN, 1);
      }
      xSemaphoreGive(mutex);
    }
    else
    {
      printf("Error taking mutex\n");
    }
  }

  nvs_close(nvs_handle_2);
}

void taskReadNVS(void)
{
  esp_err_t err;
  nvs_handle_t handle;
  int32_t stored_value_1 = 0;
  int32_t stored_value_2 = 0;

  err = nvs_open("storage", NVS_READWRITE, &handle);
  if (err != ESP_OK)
  {
    printf("Error opening NVS: %s\n", esp_err_to_name(err));
    return;
  }

  err = nvs_get_i32(handle, "th_read_num_1", &stored_value_1);
  if (err == ESP_ERR_NVS_NOT_FOUND)
  {
    printf("Value th_read_num_1 not initialized\n");
  }
  else if (err == ESP_OK)
  {
    printf("Value read by task 1: %ld\n", stored_value_1);
  }
  else
  {
    printf("Error reading th_read_num_1: %s\n", esp_err_to_name(err));
  }

  err = nvs_get_i32(handle, "th_read_num_2", &stored_value_2);
  if (err == ESP_ERR_NVS_NOT_FOUND)
  {
    printf("Value th_read_num_2 not initialized\n");
  }
  else if (err == ESP_OK)
  {
    printf("Value read by task 2: %ld\n", stored_value_2);
  }
  else
  {
    printf("Error reading th_read_num_2: %s\n", esp_err_to_name(err));
  }

  nvs_close(handle);
}

void app_main(void)
{
  esp_err_t ret = nvs_flash_init();
  if (ret != ESP_OK)
  {
    printf("NVS Flash init error: %s\n", esp_err_to_name(ret));
    return;
  }

  gpio_config_t led_conf = {
      .intr_type = GPIO_INTR_DISABLE,
      .mode = GPIO_MODE_OUTPUT,
      .pin_bit_mask = (1ULL << LED1_PIN) | (1ULL << LED2_PIN),
      .pull_up_en = GPIO_PULLUP_DISABLE,
      .pull_down_en = GPIO_PULLDOWN_ENABLE};
  gpio_config(&led_conf);

  gpio_config_t btn_conf = {
      .intr_type = GPIO_INTR_NEGEDGE,
      .mode = GPIO_MODE_INPUT,
      .pin_bit_mask = (1ULL << BTN1_PIN),
      .pull_up_en = GPIO_PULLUP_ENABLE,
      .pull_down_en = GPIO_PULLDOWN_DISABLE};
  gpio_config(&btn_conf);

  mutex = xSemaphoreCreateMutex();
  if (mutex == NULL)
  {
    printf("Error creating mutex\n");
    return;
  }

  queue_handle_1 = xQueueCreate(QUEUE_SIZE, sizeof(int16_t));
  if (queue_handle_1 == NULL)
  {
    printf("Error creating queue 1\n");
    return;
  }

  queue_handle_2 = xQueueCreate(QUEUE_SIZE, sizeof(int16_t));
  if (queue_handle_2 == NULL)
  {
    printf("Error creating queue 2\n");
    return;
  }

  th_gen_num_1 = xTaskCreate(taskGenNum1, "thread_1", 2 * 1024, NULL, 5, &th_handle_1);
  if (th_gen_num_1 != pdPASS)
  {
    printf("Error creating thread 1\n");
    return;
  }

  th_gen_num_2 = xTaskCreate(taskGenNum2, "thread_2", 2 * 1024, NULL, 5, &th_handle_2);
  if (th_gen_num_2 != pdPASS)
  {
    printf("Error creating thread 2\n");
    return;
  }

  th_read_num_1 = xTaskCreate(taskReadNum1, "thread_3", 2 * 1024, NULL, 5, &th_handle_3);
  if (th_read_num_1 != pdPASS)
  {
    printf("Error creating thread 3\n");
    return;
  }

  th_read_num_2 = xTaskCreate(taskReadNum2, "thread_4", 2 * 1024, NULL, 5, &th_handle_4);
  if (th_read_num_2 != pdPASS)
  {
    printf("Error creating thread 4\n");
    return;
  }

  while (1)
  {
    if (gpio_get_level(BTN1_PIN) == 0)
    {
      taskReadNVS();
    }
    vTaskDelay(pdMS_TO_TICKS(1000));
  }
}
